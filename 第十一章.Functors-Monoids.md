# Functors，Applicative和Monoids

`Haskell`是一个大集合，包含高阶函数，侧重算法的参数类型及类型类，对比其它语言，能让我们
在更高的角度去理解并实现`[polymorphism](https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%9E%8B_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))`。
我们不需要去思考某些类型是否属于某个庞大体系一个类型，相反，我们只要思考类型要做什么，并且
如何使用类型将它们结合在一起。`Int`类型看起来能做很多的事情，可以用于计算，可以用于排序、
或者可以用于枚举，等等。

类型类是对外开放的，我们可以自己定义自己的数据类型，思考该数据类型需要做什么及如何通过类
型类定义一些行为。正因为`Haskell`有强大的类型系统，可以让我们通过函数的类型定义知道关于
函数的一些信息，我们可以自己定义类型，定义一些非常通用、抽象的行为。我们已经看到过一些类
型类的操作，如判断是否相等、通过排序进行比较等。这些都是十分抽象且优雅的行为，但我们并不
认识这些知识点非常特别，因为其实我们在现实生活中，就一直处理这样的事情。最近一个知识点是
`functors`，它最基本的行为就是可以被`map`。`functors`是一个非常有用的例子，并且也很好
地描述了类型类中一些非常抽象的属性。在这个章节中，通过使用更健壮且更有效的`functors`(`applicative functors`)，
我们将近距离的使用、理解`functors`。其中我们也会提到`monoids`，

## Functors 终级版

在前面章节的小单元中，我们已经讨论过`functors`。如果你没有阅读过，有空的时候你应该去看一看。
这里的话，我就假装认为你已经阅读过了#。

先来简单的复习一下，`Functor`是一类可以被`map`的类型，比如`lists`、`Maybes`、`trees`
等等。在`Haskell`中，这一类型被统一定义成`Functor`类型，它只有一个类型类方法`fmap`，该
方法的类型定义为`fmap :: (a -> b) -> f a -> f b`。其类型定义说明，给我一个函数，这个函
数会使用`a`并返回`b`，或者这个`a`属于某个盒子，返回一个含有`b`的盒子。

> 建议：当你多次看到拿`盒子`来类比，主要是为什么说明`functor`是如何工作的，再后面的内容
中，我们也会使用这个类比来描述`applicative functors`和`monads`，最开始拿`盒子`做类比
可以帮助你理解`functor`，不需要去过分解读。因为有一些`functor`如果还是拿这个类比来说，就
有些牵强。一个更加正确的术语应该是`computational context`。上下文可以是一个计算的对象，
也可能是包含多个元素的列表等其它表达式。

如果你要创建一个`functor`的实例，可以使用`* -> *`，至少需要一实际类型作为类型参数。`Maybe`
可以用于创建一个实例，因为它使用一个类型参数来创建一个实际类型，如`Maybe Int`、`Maybe String`。
如果一个类型结构需要两个参数，如`Either`，我们不得不分步骤地各个参数应用于类型结构上，直到
最后只有一个类型参数应用于类型结构。所以我们不能写`instance Functor Either where`，但可以
写`instance Functor (Either a) where`，然后我们想像`fmap`就只是用于`Either a`，那么它的
类型定义如`fmap :: (b -> c) -> Either a b -> Either a c`。如你所见，`Either a`这部分是
固定的，因为`Either a`只需要使用一个参数，只是说`Either`是使用两个参数的，`fmap :: (b -> c) -> Either b -> Either c`
不会起到什么作用。

目前为止，我们已经学习了不少`Functor`的实例，如`[]`、`Maybe`、`Either a`，使用较好的方法
将函数`map`应用于每个元素。在这个章节中，我们将学习`IO`和`(->) r`这个实例，它们都是`Functor`
的实例。

如果有些类型是标识为`IO String`，说明是一个`IO`操作，当执行的时候，将离开当前运行环境从实际
中取一些字符串供我们显示，它取回的字符串将作为生成的结果。我们可以有`do`语法中使用`<-`将结果
绑定到变量名。我们注意到，`IO`操作就像一个有脚的小盒子，从外面的环境中取回一些值。我们在函数中
检查取回的数据，但检查完后，仍需要在`IO`中对数据进行封装。我们将`IO`操作与有脚的盒子进行对比，
能看出`IO`就在扮演`Functor`的角色。

让我们来看看为什么`IO`是一个`Functor`的实例。当我们`fmap`一个函数到到一个`IO`操作时，如果
我们希望有一个`IO`操作中做同样的事情，并将我们的函数应用于它取回的结果。

```Haskell
instance Functor IO where  
    fmap f action = do  
        result <- action  
        return (f result)
````
